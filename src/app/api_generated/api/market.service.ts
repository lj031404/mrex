/**
 * MREX property schema
 * This is the MREX schema for a property
 *
 * OpenAPI spec version: 1.0.0
 * Contact: jlavoie@mrex.co
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ApartmentSize } from '../model/apartmentSize';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { Listing } from '../model/listing';
import { MarketProperty } from '../model/marketProperty';
import { MarketPropertyComparable } from '../model/marketPropertyComparable';
import { MarketPropertyComparableDetails } from '../model/marketPropertyComparableDetails';
import { MarketPropertyTrendIdentifiers } from '../model/marketPropertyTrendIdentifiers';
import { MarketSearchResponse } from '../model/marketSearchResponse';
import { ModelError } from '../model/modelError';
import { Note } from '../model/note';
import { SearchListingCriteriaGeoAddress } from '../model/searchListingCriteriaGeoAddress';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class MarketService {

    protected basePath = 'https://api.mrex.co/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Address autocomplete
     * 
     * @param query Query string
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public autocomplete(query?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public autocomplete(query?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public autocomplete(query?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public autocomplete(query?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (query !== undefined && query !== null) {
            queryParameters = queryParameters.set('query', <any>query);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/autocomplete`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a search history item
     * 
     * @param body Search criteria
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSearchHistoryItem(body: SearchListingCriteriaGeoAddress, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createSearchHistoryItem(body: SearchListingCriteriaGeoAddress, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createSearchHistoryItem(body: SearchListingCriteriaGeoAddress, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createSearchHistoryItem(body: SearchListingCriteriaGeoAddress, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createSearchHistoryItem.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('post',`${this.basePath}/market/search/history`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve search history
     * 
     * @param searchId Search identifier
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSearchHistoryItem(searchId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteSearchHistoryItem(searchId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteSearchHistoryItem(searchId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteSearchHistoryItem(searchId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (searchId === null || searchId === undefined) {
            throw new Error('Required parameter searchId was null or undefined when calling deleteSearchHistoryItem.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/market/search/history/${encodeURIComponent(String(searchId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a listing
     * 
     * @param listingId ID of the listing
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getListing(listingId: string, observe?: 'body', reportProgress?: boolean): Observable<Listing>;
    public getListing(listingId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Listing>>;
    public getListing(listingId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Listing>>;
    public getListing(listingId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (listingId === null || listingId === undefined) {
            throw new Error('Required parameter listingId was null or undefined when calling getListing.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Listing>('get',`${this.basePath}/market/listings/${encodeURIComponent(String(listingId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a property
     * 
     * @param propertyId ID of the property
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMarketProperty(propertyId: string, observe?: 'body', reportProgress?: boolean): Observable<MarketProperty>;
    public getMarketProperty(propertyId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MarketProperty>>;
    public getMarketProperty(propertyId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MarketProperty>>;
    public getMarketProperty(propertyId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling getMarketProperty.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<MarketProperty>('get',`${this.basePath}/market/properties/${encodeURIComponent(String(propertyId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a chart data
     * 
     * @param propertyId ID of the property
     * @param chartId ID of the chart
     * @param apartmentSize 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMarketPropertyTrends(propertyId: string, chartId: MarketPropertyTrendIdentifiers, apartmentSize: ApartmentSize, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public getMarketPropertyTrends(propertyId: string, chartId: MarketPropertyTrendIdentifiers, apartmentSize: ApartmentSize, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public getMarketPropertyTrends(propertyId: string, chartId: MarketPropertyTrendIdentifiers, apartmentSize: ApartmentSize, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public getMarketPropertyTrends(propertyId: string, chartId: MarketPropertyTrendIdentifiers, apartmentSize: ApartmentSize, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling getMarketPropertyTrends.');
        }

        if (chartId === null || chartId === undefined) {
            throw new Error('Required parameter chartId was null or undefined when calling getMarketPropertyTrends.');
        }

        if (apartmentSize === null || apartmentSize === undefined) {
            throw new Error('Required parameter apartmentSize was null or undefined when calling getMarketPropertyTrends.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (apartmentSize !== undefined && apartmentSize !== null) {
            queryParameters = queryParameters.set('apartmentSize', <any>apartmentSize);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2001>('get',`${this.basePath}/market/properties/${encodeURIComponent(String(propertyId))}/trends/${encodeURIComponent(String(chartId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get detailed information about a place Id
     * 
     * @param placeId placeId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPlaceIdDetails(placeId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getPlaceIdDetails(placeId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getPlaceIdDetails(placeId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getPlaceIdDetails(placeId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (placeId === null || placeId === undefined) {
            throw new Error('Required parameter placeId was null or undefined when calling getPlaceIdDetails.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/places/${encodeURIComponent(String(placeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a comparable details
     * 
     * @param propertyId ID of the property
     * @param comparablePropertyId ID of the property
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPropertyComparableDetail(propertyId: string, comparablePropertyId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MarketPropertyComparableDetails>>;
    public getPropertyComparableDetail(propertyId: string, comparablePropertyId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketPropertyComparableDetails>>>;
    public getPropertyComparableDetail(propertyId: string, comparablePropertyId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketPropertyComparableDetails>>>;
    public getPropertyComparableDetail(propertyId: string, comparablePropertyId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling getPropertyComparableDetail.');
        }

        if (comparablePropertyId === null || comparablePropertyId === undefined) {
            throw new Error('Required parameter comparablePropertyId was null or undefined when calling getPropertyComparableDetail.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<MarketPropertyComparableDetails>>('get',`${this.basePath}/market/properties/${encodeURIComponent(String(propertyId))}/comparables/${encodeURIComponent(String(comparablePropertyId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a property comparables
     * 
     * @param propertyId ID of the property
     * @param ignore Ignore properties
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPropertyComparables(propertyId: string, ignore?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Array<MarketPropertyComparable>>;
    public getPropertyComparables(propertyId: string, ignore?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MarketPropertyComparable>>>;
    public getPropertyComparables(propertyId: string, ignore?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MarketPropertyComparable>>>;
    public getPropertyComparables(propertyId: string, ignore?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling getPropertyComparables.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (ignore) {
            ignore.forEach((element) => {
                queryParameters = queryParameters.append('ignore', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<MarketPropertyComparable>>('get',`${this.basePath}/market/properties/${encodeURIComponent(String(propertyId))}/comparables`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve search history
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSearchHistory(observe?: 'body', reportProgress?: boolean): Observable<Array<SearchListingCriteriaGeoAddress>>;
    public getSearchHistory(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SearchListingCriteriaGeoAddress>>>;
    public getSearchHistory(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SearchListingCriteriaGeoAddress>>>;
    public getSearchHistory(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<SearchListingCriteriaGeoAddress>>('get',`${this.basePath}/market/search/history`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search listings around an address and given a set of criteria
     * 
     * @param body Search criteria
     * @param sort Field to sort
     * @param countOnly Return only the count
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchNearListingsByAddress(body: SearchListingCriteriaGeoAddress, sort?: string, countOnly?: string, observe?: 'body', reportProgress?: boolean): Observable<MarketSearchResponse>;
    public searchNearListingsByAddress(body: SearchListingCriteriaGeoAddress, sort?: string, countOnly?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MarketSearchResponse>>;
    public searchNearListingsByAddress(body: SearchListingCriteriaGeoAddress, sort?: string, countOnly?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MarketSearchResponse>>;
    public searchNearListingsByAddress(body: SearchListingCriteriaGeoAddress, sort?: string, countOnly?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling searchNearListingsByAddress.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (countOnly !== undefined && countOnly !== null) {
            queryParameters = queryParameters.set('countOnly', <any>countOnly);
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MarketSearchResponse>('post',`${this.basePath}/market/search`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Attach a note to a property
     * 
     * @param body Search criteria
     * @param propertyId ID of the property
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateListingNote(body: Note, propertyId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateListingNote(body: Note, propertyId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateListingNote(body: Note, propertyId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateListingNote(body: Note, propertyId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateListingNote.');
        }

        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling updateListingNote.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/market/properties/${encodeURIComponent(String(propertyId))}/note`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a search history item
     * 
     * @param body Search criteria
     * @param searchId Search identifier
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSearchHistoryItem(body: SearchListingCriteriaGeoAddress, searchId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateSearchHistoryItem(body: SearchListingCriteriaGeoAddress, searchId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateSearchHistoryItem(body: SearchListingCriteriaGeoAddress, searchId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateSearchHistoryItem(body: SearchListingCriteriaGeoAddress, searchId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateSearchHistoryItem.');
        }

        if (searchId === null || searchId === undefined) {
            throw new Error('Required parameter searchId was null or undefined when calling updateSearchHistoryItem.');
        }

        let headers = this.defaultHeaders;

        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // authentication (oAuthNoScopes) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<any>('put',`${this.basePath}/market/search/history/${encodeURIComponent(String(searchId))}`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
